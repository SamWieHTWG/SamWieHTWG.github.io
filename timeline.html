<!DOCTYPE html>
<html lang="en">
  <head>
    <!-- Bootstrap 4 CSS -->
    <link
      href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.3/dist/css/bootstrap.min.css"
      rel="stylesheet"
    />
    <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.3/dist/js/bootstrap.bundle.min.js"></script>

    <title>three.js webgl - postprocessing - unreal bloom selective</title>
    <meta charset="utf-8" />
    <meta
      name="viewport"
      content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0"
    />
    <style>
      html {
        cursor: url("cursor2.png"), auto;
      }

      body {
        margin: 0;
      }

      canvas {
        display: block;
      }

      #meinButton {
        position: absolute;
        top: 20px;
        left: 20px;
        z-index: 10;
        /* Stellt sicher, dass der Button über dem Canvas liegt */
      }
    </style>
  </head>

  <body>
    <script type="x-shader/x-vertex" id="vertexshader">

      varying vec2 vUv;

      void main() {

      	vUv = uv;

      	gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );

      }
    </script>

    <script type="x-shader/x-fragment" id="fragmentshader">

      uniform sampler2D baseTexture;
      uniform sampler2D bloomTexture;

      varying vec2 vUv;

      void main() {

      	gl_FragColor = ( texture2D( baseTexture, vUv ) + vec4( 1.0 ) * texture2D( bloomTexture, vUv ) );

      }
    </script>
    <script type="importmap">
      {
        "imports": {
          "three": "https://cdn.jsdelivr.net/npm/three@0.164.1/build/three.module.min.js",
          "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.164.1/examples/jsm/"
        }
      }
    </script>

    <script type="module">
      import * as THREE from "three";
      import { FontLoader } from "three/addons/loaders/FontLoader.js";
      import { SVGLoader } from "three/addons/loaders/SVGLoader.js";
      import { TextGeometry } from "three/addons/geometries/TextGeometry.js";

      let scene, camera, renderer, circle, arrow;
      let arrowLength = 100,
        speed = 0.05;

      var lineStart = -arrowLength / 2;
      var lineEnd = arrowLength / 2;


      var MARKERSIZE = 0.002 * 100;
      var MARKERLENGTH = 0.1 * 100;
      var MARKERSIZEYEAR = 0.001 * 100;
      var MARKERLENGTHYEAR = 0.05 * 100;
      var YEARHEIGHT = 5;
      var YEARWIDTH = 10;
      var size = 5;
      var TEXTHEIGTH = 35 *  0.43 *0.8;
      var TEXTWIDTH = 45   * 0.3  *0.8;

      scene = new THREE.Scene();


      renderer = new THREE.WebGLRenderer();
      renderer.setSize(window.innerWidth, window.innerHeight);
      renderer.setClearColor(0xf5f5f5); // Set background color to grey
      document.body.appendChild(renderer.domElement);

      // Create a black circle
      // const circleGeometry = new THREE.CircleGeometry(0.01 * 100, 100);
      // const circleMaterial = new THREE.MeshBasicMaterial({ color: 0x000000 }); // Black color
      // circle = new THREE.Mesh(circleGeometry, circleMaterial);
      // circle.position.x = lineStart;
      // scene.add(circle);

      // Create a black line
      const points = [];
      points.push(new THREE.Vector3(lineStart, 0, 0));
      points.push(new THREE.Vector3(lineEnd, 0, 0));
      const lineGeometry = new THREE.BufferGeometry().setFromPoints(points);
      const lineMaterial = new THREE.LineBasicMaterial({ color: 0x000000 });
      var line = new THREE.Line(lineGeometry, lineMaterial);
      scene.add(line);

      // Add a vertical marker at the beginning of the timeline
      const markerMaterial = new THREE.MeshBasicMaterial({ color: 0x000000 });
      
      {
      const markerGeometry = new THREE.BoxGeometry(MARKERSIZEYEAR, MARKERLENGTHYEAR, 0); // Thin vertical line
      const marker = new THREE.Mesh(markerGeometry, markerMaterial);
      var markerPos = calcPosFromDate(1, 2025);
      marker.position.set(markerPos, 0, 0);
      scene.add(marker);
            addSVGtoScene(
        "svgs/2025.svg",
        YEARWIDTH,
        YEARHEIGHT,
        markerPos,
        MARKERLENGTHYEAR/2 + YEARHEIGHT / 2,
        0
      );
      }
      {
      const markerGeometry = new THREE.BoxGeometry(MARKERSIZEYEAR, MARKERLENGTHYEAR, 0); // Thin vertical line
      const marker = new THREE.Mesh(markerGeometry, markerMaterial);
      var markerPos = calcPosFromDate(1, 2027);
      marker.position.set(markerPos, 0, 0);
      scene.add(marker);
            addSVGtoScene(
        "svgs/2027.svg",
        YEARWIDTH,
        YEARHEIGHT,
        markerPos,
        MARKERLENGTHYEAR/2 + YEARHEIGHT / 2,
        0
      );
      }
      {
      const markerGeometry = new THREE.BoxGeometry(MARKERSIZEYEAR, MARKERLENGTHYEAR, 0); // Thin vertical line
      const marker = new THREE.Mesh(markerGeometry, markerMaterial);
      var markerPos = calcPosFromDate(1, 2028);
      marker.position.set(markerPos, 0, 0);
      scene.add(marker);
            addSVGtoScene(
        "svgs/2028.svg",
        YEARWIDTH,
        YEARHEIGHT,
        markerPos,
        MARKERLENGTHYEAR/2 + YEARHEIGHT / 2,
        0
      );
      }
      {
      const markerGeometry = new THREE.BoxGeometry(MARKERSIZEYEAR, MARKERLENGTHYEAR, 0); // Thin vertical line
      const marker = new THREE.Mesh(markerGeometry, markerMaterial);
      var markerPos = calcPosFromDate(1, 2029);
      marker.position.set(markerPos, 0, 0);
      scene.add(marker);
            addSVGtoScene(
        "svgs/2029.svg",
        YEARWIDTH,
        YEARHEIGHT,
        markerPos,
        MARKERLENGTHYEAR/2 + YEARHEIGHT / 2,
        0
      );
      }
      {
      const markerGeometry = new THREE.BoxGeometry(MARKERSIZEYEAR, MARKERLENGTHYEAR, 0); // Thin vertical line
      const marker = new THREE.Mesh(markerGeometry, markerMaterial);
      var markerPos = calcPosFromDate(1, 2026);
      marker.position.set(markerPos, 0, 0);
      scene.add(marker);
            addSVGtoScene(
        "svgs/2026.svg",
        YEARWIDTH,
        YEARHEIGHT,
        markerPos,
        MARKERLENGTHYEAR/2 + YEARHEIGHT / 2,
        0
      );
      }

      // instantiate a loader
      // instantiate a loader

      let svgMeshes = [];

      // Add a vertical marker at the beginning of the timeline
      var pos;
      {
        var geo = new THREE.BoxGeometry(MARKERSIZE, MARKERLENGTH, 0); // Thin vertical line
        var m = new THREE.Mesh(geo, markerMaterial);
        pos = calcPosFromDate(8, 2024);
        m.position.set(pos, MARKERLENGTH / 2, 0);
        scene.add(m);

      }
      addSVGtoScene(
        "svgs/Inkraft.svg",
        TEXTWIDTH,
        TEXTHEIGTH,
        pos,
        MARKERLENGTH + TEXTHEIGTH / 2,
        0
      );

      {
        var geo = new THREE.BoxGeometry(MARKERSIZE, MARKERLENGTH, 0); // Thin vertical line
        var m = new THREE.Mesh(geo, markerMaterial);
        pos = calcPosFromDate(11, 2024);
        m.position.set(pos, -MARKERLENGTH / 2, 0);
        scene.add(m);
      }
      addSVGtoScene(
        "svgs/Veroeffentlichung.svg",
        TEXTWIDTH,
        TEXTHEIGTH,
        pos,
         -1*( MARKERLENGTH + TEXTHEIGTH / 2),
        0
      );


      {
        var geo = new THREE.BoxGeometry(MARKERSIZE, MARKERLENGTH, 0); // Thin vertical line
        var m = new THREE.Mesh(geo, markerMaterial);
        pos = calcPosFromDate(4, 2025);
        m.position.set(pos, MARKERLENGTH / 2, 0);
        scene.add(m);
      }
      addSVGtoScene(
        "svgs/Harmon.svg",
        TEXTWIDTH,
        TEXTHEIGTH,
        pos,
         1*( MARKERLENGTH + TEXTHEIGTH / 2),
        0
      );

      {
        var geo = new THREE.BoxGeometry(MARKERSIZE, MARKERLENGTH, 0); // Thin vertical line
        var m = new THREE.Mesh(geo, markerMaterial);
        pos = calcPosFromDate(9, 2025);
        m.position.set(pos, -1* MARKERLENGTH / 2, 0);
        scene.add(m);
      }
      addSVGtoScene(
        "svgs/Verpflicht.svg",
        TEXTWIDTH,
        TEXTHEIGTH,
        pos,
         -1*( MARKERLENGTH + TEXTHEIGTH / 2),
        0
      );

      {
        var geo = new THREE.BoxGeometry(MARKERSIZE, MARKERLENGTH, 0); // Thin vertical line
        var m = new THREE.Mesh(geo, markerMaterial);
        pos = calcPosFromDate(5, 2026);
        m.position.set(pos, 1* MARKERLENGTH / 2, 0);
        scene.add(m);
      }
      addSVGtoScene(
        "svgs/System.svg",
        TEXTWIDTH,
        TEXTHEIGTH,
        pos,
         1*( MARKERLENGTH + TEXTHEIGTH / 2),
        0
      );

      {
        var geo = new THREE.BoxGeometry(MARKERSIZE, MARKERLENGTH, 0); // Thin vertical line
        var m = new THREE.Mesh(geo, markerMaterial);
        pos = calcPosFromDate(6, 2027);
        m.position.set(pos, -1* MARKERLENGTH / 2, 0);
        scene.add(m);
      }
      addSVGtoScene(
        "svgs/Schritt.svg",
        TEXTWIDTH,
        TEXTHEIGTH,
        pos,
         -1*( MARKERLENGTH + TEXTHEIGTH / 2),
        0
      );

      {
        var geo = new THREE.BoxGeometry(MARKERSIZE, MARKERLENGTH, 0); // Thin vertical line
        var m = new THREE.Mesh(geo, markerMaterial);
        pos = calcPosFromDate(7, 2027);
        m.position.set(pos, 1* MARKERLENGTH / 2, 0);
        scene.add(m);
      }
      addSVGtoScene(
        "svgs/Imple.svg",
        TEXTWIDTH,
        TEXTHEIGTH,
        pos,
         1*( MARKERLENGTH + TEXTHEIGTH / 2),
        0
      );

      {
        var geo = new THREE.BoxGeometry(MARKERSIZE, MARKERLENGTH, 0); // Thin vertical line
        var m = new THREE.Mesh(geo, markerMaterial);
        pos = calcPosFromDate(4, 2028);
        m.position.set(pos, -1* MARKERLENGTH / 2, 0);
        scene.add(m);
      }
      addSVGtoScene(
        "svgs/DPPVerpf.svg",
        TEXTWIDTH,
        TEXTHEIGTH,
        pos,
         -1*( MARKERLENGTH + TEXTHEIGTH / 2),
        0
      );

      {
        var geo = new THREE.BoxGeometry(MARKERSIZE, MARKERLENGTH, 0); // Thin vertical line
        var m = new THREE.Mesh(geo, markerMaterial);
        pos = calcPosFromDate(10, 2028);
        m.position.set(pos, 1* MARKERLENGTH / 2, 0);
        scene.add(m);
      }
      addSVGtoScene(
        "svgs/Ökoricht.svg",
        TEXTWIDTH,
        TEXTHEIGTH,
        pos,
         1*( MARKERLENGTH + TEXTHEIGTH / 2),
        0
      );


      var cameraLenght =  0.6 * arrowLength;

    // camera = new THREE.OrthographicCamera(
    //     -cameraLenght,
    //     cameraLenght,
    //     cameraLenght,
    //     -cameraLenght
    //     // 1,
    //     // 1000
    //   );
      camera = new THREE.PerspectiveCamera( ); //cameraLenght, 0.5, 1, 1000 );
      camera.position.set(lineStart, 0, 100);
      camera.lookAt(lineStart, 0, 0);





      function animate() {
        requestAnimationFrame(animate);

        // Move the circle along the arrow
        camera.position.x += speed;
        // if (circle.position.x > lineEnd)
          // Reset to start once end is reached
          // circle.position.x = lineStart;
        renderer.render(scene, camera);
        size += 0.1;
        if (svgMeshes[0]) {
          // updateSVG(svgMeshes[0], 10+size, 10+size, 0, 0, 0);
        }
        // updateTextSize("2025", size);
      }

      animate();

      function calcPosFromDate(month, year) {
        // Set the start date to October 1, 2024
        const startDate = new Date(2024, 1, 1); // Month is 0-indexed (9 is October)
        const endDate = new Date(2029, 11, 31); // Month is 0-indexed (11 is December)
        const diffTimeAll = endDate - startDate;
        const diffDaysAll = diffTimeAll / (1000 * 60 * 60 * 24);

        const date = new Date(year, month, 1);
        const diffTime = date - startDate;
        const diffDays = diffTime / (1000 * 60 * 60 * 24);

        // norm to pos
        var length = (diffDays / diffDaysAll) * arrowLength;

        return lineStart + length;
      }

      function addSVGtoScene2(path, width, height, x, y, z) {
        const loader = new SVGLoader();
        loader.load(
          path,
          function (data) {
            const paths = data.paths;
            const group = new THREE.Group();

            for (let i = 0; i < paths.length; i++) {
              const path = paths[i];
              const material = new THREE.MeshBasicMaterial({
                color: path.color,
                side: THREE.DoubleSide,
                depthWrite: false,
                transparent: true,
              });

              const shapes = path.toShapes(true);

              for (let j = 0; j < shapes.length; j++) {
                const shape = shapes[j];
                const geometry = new THREE.ShapeGeometry(shape);
                const mesh = new THREE.Mesh(geometry, material);
                mesh.scale.multiplyScalar(0.01); // Scale down the SVG
                group.add(mesh);
              }
            }

            // Calculate the bounding box to get SVG size and set the scale according to desired width and height
            group.scale.set(width, height, 1);
            group.position.set(x, y, z);
            scene.add(group);

            // Store the group with its details in a map for later reference
            group.userData = { path, width, height, x, y, z }; // Store original details
            svgMeshes.push(group); // Assuming svgMeshes is an array visible in this scope
          },
          undefined,
          function (error) {
            console.error("Error loading SVG:", error);
          }
        );
      }

      function addSVGtoScene(path, width, height, x, y, z) {
        const loader = new THREE.TextureLoader();
        loader.load(
          path,
          function (texture) {
            texture.minFilter = THREE.NearestFilter; // Setting minification filter
            texture.magFilter = THREE.NearestFilter; // Setting magnification filter

            const material = new THREE.MeshBasicMaterial({
              map: texture,
              transparent: true, // Useful for SVGs with transparent backgrounds
              side: THREE.DoubleSide, // Render texture on both sides of the mesh
            });
            const geometry = new THREE.PlaneGeometry(width, height);
            const mesh = new THREE.Mesh(geometry, material);
            mesh.position.set(x, y, z);
            scene.add(mesh);

            // Store the mesh with its details in a map for later reference
            mesh.userData = { path, width, height, x, y, z }; // Store original details
            svgMeshes.push(mesh); // Assuming svgMeshes is an array visible in this scope
          },
          undefined,
          function (error) {
            console.error("Error loading SVG:", error);
          }
        );
      }

      function updateSVG(mesh, newWidth, newHeight, newX, newY, newZ) {
        // Update geometry size
        mesh.geometry.dispose(); // Dispose of the old geometry first
        mesh.geometry = new THREE.PlaneGeometry(newWidth, newHeight);

        // Update position
        mesh.position.set(newX, newY, newZ);

        // Optionally update the userData if you need to keep track of changes
        mesh.userData.width = newWidth;
        mesh.userData.height = newHeight;
        mesh.userData.x = newX;
        mesh.userData.y = newY;
        mesh.userData.z = newZ;
      }
    </script>
  </body>
</html>
