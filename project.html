<!DOCTYPE html>
<html lang="en">
  <head>
    <!-- Bootstrap 4 CSS -->
    <link
      href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.3/dist/css/bootstrap.min.css"
      rel="stylesheet"
    />
    <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.3/dist/js/bootstrap.bundle.min.js"></script>

    <title>three.js webgl - postprocessing - unreal bloom selective</title>
    <meta charset="utf-8" />
    <meta
      name="viewport"
      content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0"
    />
    <style>
      html {
        /* cursor: url("cursor2.png"), auto; */
      }

      body {
        margin: 0;
      }

      canvas {
        display: block;
      }

      #meinButton {
        position: absolute;
        top: 20px;
        left: 20px;
        z-index: 10;
        /* Stellt sicher, dass der Button über dem Canvas liegt */
      }
    </style>
  </head>

  <body>
    <script type="x-shader/x-vertex" id="vertexshader">

      varying vec2 vUv;

      void main() {

      	vUv = uv;

      	gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );

      }
    </script>

    <script type="x-shader/x-fragment" id="fragmentshader">

      uniform sampler2D baseTexture;
      uniform sampler2D bloomTexture;

      varying vec2 vUv;

      void main() {

      	gl_FragColor = ( texture2D( baseTexture, vUv ) + vec4( 1.0 ) * texture2D( bloomTexture, vUv ) );

      }
    </script>
    <script type="importmap">
      {
        "imports": {
          "three": "https://cdn.jsdelivr.net/npm/three@0.164.1/build/three.module.min.js",
          "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.164.1/examples/jsm/"
        }
      }
    </script>

    <script type="module">
      import * as THREE from "three";

      import { OrbitControls } from "three/addons/controls/OrbitControls.js";
      import { EffectComposer } from "three/addons/postprocessing/EffectComposer.js";
      import { RenderPass } from "three/addons/postprocessing/RenderPass.js";
      import { ShaderPass } from "three/addons/postprocessing/ShaderPass.js";
      import { UnrealBloomPass } from "three/addons/postprocessing/UnrealBloomPass.js";
      import { OutputPass } from "three/addons/postprocessing/OutputPass.js";
      import { FontLoader } from "three/addons/loaders/FontLoader.js";
      import { OBJLoader } from "three/addons/loaders/OBJLoader.js";
      import { TextGeometry } from "three/addons/geometries/TextGeometry.js";

      // Setup the scene
      const scene = new THREE.Scene();
      const camera = new THREE.PerspectiveCamera(
        75,
        window.innerWidth / window.innerHeight,
        0.1,
        1000
      );

      camera.position.x = 20.536587973159705;
      camera.position.y = 3.6524715195081896;
      camera.position.z = 17;

      const renderer = new THREE.WebGLRenderer();
      renderer.setSize(window.innerWidth, window.innerHeight);
      document.body.appendChild(renderer.domElement);

      // Set the background to grey
      scene.background = new THREE.Color(0xf5f5f5);

      // Create a light
      const light = new THREE.AmbientLight(0xffffff); // soft white light
      scene.add(light);

      // Set up the OBJ loader
      const loader = new OBJLoader();

      // Load a .obj file
      await    loader.load(
        "models/project1.obj", // Path to the .obj file
        function (object) {
          for(var idx=0; idx<object.children.length; idx++)
        {
          const edgeGeometry = new THREE.EdgesGeometry(
            object.children[idx].geometry
          );
          const linesMaterial = new THREE.LineBasicMaterial({
            color: 0x000000,
          });
          const edges = new THREE.LineSegments(edgeGeometry, linesMaterial);
          scene.add(edges); // Add the edge lines to the scene
          // edges.position.set(0, 0, 0); // Set the position of the edges
        }
        //   scene.add(object); // Add the loaded object to the scene
        //   object.position.set(0, 0, 0); // Set the position of the object
        },
        function (xhr) {
          console.log((xhr.loaded / xhr.total) * 100 + "% loaded"); // Optional: console log loading progress
        },
        function (error) {
          console.log("An error happened"); // Optional: console log on error
        }
      );

      // OrbitControls
      const controls = new OrbitControls(camera, renderer.domElement);
      // controls.update();

      controls.enableRotate = false; // Disables rotation
      controls.enablePan = false; // Disables panning
      controls.enableZoom = false; // Disables zooming

      // Position the camera
      camera.position.x = 20.536587973159705;
      camera.position.y = 3.6524715195081896;
      camera.position.z = 17;

      
      // Berechnen des Zentrums und der Größe der Szene
      function getSceneCenter(scene) {
        let boundingBox = new THREE.Box3();

        // Traverse all children in the scene
        scene.traverse(function (object) {
            if (object.isMesh) {
                object.geometry.computeBoundingBox(); // Ensure the geometry's bounding box is calculated
                let box = object.geometry.boundingBox.clone();
                box.applyMatrix4(object.matrixWorld); // Apply the object's world matrix to the box
                boundingBox.union(box); // Merge with the main bounding box
            }
        });

        let center = new THREE.Vector3();
        boundingBox.getCenter(center); // Get the center of the bounding box
        return center;
    }
      var center = getSceneCenter(scene);
      // const box = new THREE.Box3().setFromObject(scene);
      // let cubeGeometry = new THREE.BoxGeometry(1, 1, 1);
      // let cubeMaterial = new THREE.MeshBasicMaterial({ color: 0x00ff00 });
      //   let cube = new THREE.Mesh(cubeGeometry, cubeMaterial);
      //   cube.position.set(5, 1, 5);
      // scene.add(cube);
      center.x = 5;
      center.y = 1;
      center.z = 5;
      // var center = box.getCenter(new THREE.Vector3());


      // Camera Position - x: , y: , z: 16.981153919381356
      // Animation loop
      function animate() {
        
        requestAnimationFrame(animate);
        // controls.update(); // only required if controls.enableDamping or controls.autoRotate are set to true
        
        cameraRotation();
        renderer.render(scene, camera);
        // console.log(`Camera Position - x: ${camera.position.x}, y: ${camera.position.y}, z: ${camera.position.z}`);

      }

      var time_last = 0;


         function calculateSphericalCoordinates(center, point) {
        // Destructure the center and point coordinates
        var x_m = center.x;
        var y_m = center.y;
        var z_m = center.z;
        var x = point[0];
        var y = point[1];
        var z = point[2];

        // Translate point to the origin based on the center
        const x_prime = x - x_m;
        const y_prime = y - y_m;
        const z_prime = z - z_m;

        // Calculate the spherical coordinates
        const r = Math.sqrt(
          x_prime * x_prime + y_prime * y_prime + z_prime * z_prime
        );
        var theta = Math.acos(z_prime / r);
        var phi = Math.atan2(y_prime, x_prime);

        // Return the spherical coordinates
        return { r, theta, phi };
      }
       function calculateRotation(center, point, dt) {
        // Destructure the center and point coordinates
        var x_m = center.x;
        var y_m = center.y;
        var z_m = center.z;
        var x = point[0];
        var y = point[1];
        var z = point[2];

        // Translate point to the origin based on the center
        const x_prime = x - x_m;
        const y_prime = y - y_m;
        const z_prime = z - z_m;

        // Example Quaternion
        const quaternion = new THREE.Quaternion();
        quaternion.setFromAxisAngle(new THREE.Vector3(0, 1, 0), 0.1 * dt); // Rotate around Y-axis by 45 degrees

        // Create a Vector3 from the coordinates
        let vector = new THREE.Vector3(x_prime, y_prime, z_prime);

        // Apply the quaternion to the vector
        vector.applyQuaternion(quaternion);

        vector.x = center.x + vector.x;
        vector.y = center.y + vector.y;
        vector.z = center.z + vector.z;
        return vector;
      }

      function cameraRotation()
      {
          const time = Date.now() * 0.001; // Zeit in Sekunden
        var dt = time - time_last;
        if (Math.abs(dt) > 1) dt = 0;
        time_last = time;

        var pos = [camera.position.x, camera.position.y, camera.position.z];
        var polar = calculateSphericalCoordinates(center, pos);
        var vector = calculateRotation(center, pos, dt);

        polar.phi = polar.phi + dt * 0.5;

        // console.log(polar.theta)
        // polar.phi = polar.phi + dt * 0.02;
        // console.log(polar.theta)
        // var vals = sphericalToCartesian(polar.r, polar.theta, polar.phi)
        // var vals = quaternionToCartesian(polar.r,q)
        // Kamerabewegung aktualisieren
        camera.position.x = vector.x;
        camera.position.y = vector.y;
        camera.position.z = vector.z;

        // Die Kamera sollte auf das Zentrum eder Szene ausgerichtet sein
        camera.lookAt(center);
      }

      animate();
    </script>
  </body>
</html>
